<html>
	<head>
		<title>Tick Tack Cube - three.js Experiment</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.min.js"></script>
		<script src="js/tween.js"></script>
		<script src="js/key.js"></script>
		<script src="js/mouse.js"></script>
		<script>
			function Block(size) {
				this.size    = size || 100;
				this.bgColor = 0xcccccc;
				this.xColor  = 0xcc0000;
				this.oColor  = 0x0000cc;
			};

			Block.prototype = Object.create(THREE.Mesh.prototype);
			Block.prototype.constructor = Block;

			Block.prototype.init = function() {
				this.makeBox();
				this.makeX();
				this.makeO();
			};

			Block.prototype.makeBox = function() {
				var geometry = new THREE.BoxGeometry(this.size, this.size, this.size);
				var material = new THREE.MeshLambertMaterial({color: this.bgColor});
				THREE.Mesh.call(this, geometry, material);
			};

			Block.prototype.makeX = function() {
				var geometry = new THREE.CylinderGeometry(this.size/10, this.size/10, this.size);
				var material = new THREE.MeshPhongMaterial({color: this.xColor});

				var x1 = new THREE.Mesh(geometry.clone(), material.clone());
				x1.position.x = this.size/2;
				x1.rotation.x = -Math.PI/4;
				this.add(x1);

				var x2 = new THREE.Mesh(geometry.clone(), material.clone());
				x2.position.x = this.size/2;
				x2.rotation.x = Math.PI/4;
				this.add(x2);
			};

			Block.prototype.makeO = function() {
				var geometry = new THREE.TorusGeometry(this.size/3, this.size/10, 8, 50);
				var material = new THREE.MeshPhongMaterial({color: this.oColor});

				var o = new THREE.Mesh(geometry, material);
				o.position.z = -this.size/2;
				this.add(o);
			};

			// Sets the outward-facing direction for this cube
			// x, y, z values should be either 0, 1, 2, or 3, which
			// is the multiplier for rotation
			Block.prototype.setFace = function(x, y, z) {
				var turn = Math.PI/2;
				this.rotation.set(x*turn, y*turn, z*turn);
			};

			Block.prototype.turnX = function() {

			};

			Block.prototype.turnO = function() {

			};

			Block.prototype.clear = function() {

			};

			function Cube(blockSize) {
				this.blockSize = blockSize || 1;
				this.blocks = [];
				THREE.Object3D.call(this);
			}

			Cube.prototype = THREE.Object3D.prototype;

			Cube.prototype.generate = function(scene) {
				var count = 27;

				var holder = new THREE.Object3D();
				holder.position.set(-this.blockSize, -this.blockSize, -this.blockSize);
				this.add(holder);

				for (var i=0; i<count; i++) {
					var shade = i % 2 ? 0xffffff : 0xcccccc;

					var block = new Block(this.blockSize);
					block.bgColor = shade;
					block.init();

					var x = this.blockSize * (i % 3);
					var y = this.blockSize * (Math.floor((i % 9) / 3));
					var z = this.blockSize * (Math.floor(i / 9));

					block.position.set(x, y, z);

					holder.add(block);
					this.blocks.push(block);
				}

				scene.add(this);
			};
		</script>
		<script>
			var world = {
				angle     : 60,
				near      : 1,
				far       : 1000,
				blockSize : 100,
				width     : window.innerWidth,
				height    : window.innerHeight
			}

			var cube;

			var scene, camera, renderer;

			function init() {
				scene = new THREE.Scene();
				lights();
				camera();
				action();
			}

			function lights() {
				var toplight = new THREE.HemisphereLight(0xffffff, 0x666666);
				scene.add(toplight);

				var lightbulb = new THREE.PointLight(0xffffff, 1, world.far);
				lightbulb.position.set(world.width/2, world.height/2, world.near);
				scene.add(lightbulb);
			}

			function camera() {
				camera = new THREE.PerspectiveCamera(world.angle, world.width / world.height, world.near, world.far);
				camera.position.z = world.far/2;
			}

			function action() {
				renderer = new THREE.WebGLRenderer();
				renderer.setSize(world.width, world.height);
				document.body.appendChild(renderer.domElement);
				setup();
				loop();
			}

			function setup() {
				cube = new Cube(world.blockSize);
				cube.generate(scene);
			}

			function draw() {
				if (Key.isDown(Key.SPACEBAR)) {
					if (Key.isDown(Key.SHIFT)) {
						camera.position.z += 10;
					}
					else {
						camera.position.z -= 10;
					}
				}
			}

			function loop() {
				requestAnimationFrame(loop);
				draw();
				TWEEN.update();
				renderer.render(scene, camera);
			}

			function turn(object, axis, direction) {
				var radian   = Math.PI/2;
				var current  = object.rotation[axis];
				var rotation = current + (direction * radian);

				// Used to force-fit into right angles
				var index    = Math.round(rotation / radian);
				var target   = index * radian;

				var tween = new TWEEN.Tween({angle: object.rotation[axis]});
				tween.to({angle: target})
					.easing(TWEEN.Easing.Elastic.Out)
					.onUpdate(function() {
						object.rotation[axis] = this.angle;
					})
					.start();
			}

			Key.on('up', function(event) {
				if (event.UP_ARROW)    turn(cube, 'x', 1);
				if (event.DOWN_ARROW)  turn(cube, 'x', -1);
				if (event.RIGHT_ARROW) turn(cube, 'y', 1);
				if (event.LEFT_ARROW)  turn(cube, 'y', -1);
				if (event.NUM_1)       turn(cube.blocks[0], 'x', 1);
				if (event.NUM_2)       turn(cube.blocks[0], 'y', 1);
				if (event.NUM_3)       turn(cube.blocks[0], 'z', 1);
			});

			Mouse.on('up', function(event) {
				console.info(event);
			});

			init();
		</script>
	</body>
</html>
